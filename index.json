{
  "docs/mocking-jsruntime.html": {
    "href": "docs/mocking-jsruntime.html",
    "title": "Mocking IJsRuntime | bUnit",
    "keywords": "Mocking IJsRuntime This page is on the todo list. To see examples of how to mock the JsRuntime, go to the C# test examples page."
  },
  "docs/basics-of-blazor-component-testing.html": {
    "href": "docs/basics-of-blazor-component-testing.html",
    "title": "Basics of Blazor component testing | bUnit",
    "keywords": "Basics of Blazor component testing To test a component, you first have to render it with parameters, cascading values, and services passed into it. Then, you need access to the component's instance and the markup it has produced, so you can inspect and interact with both. There are three different ways of doing this in the library: C# based tests With C# based tests, you write all your testing logic in C# files, i.e. like regular unit tests. Razor based tests (EXPERIMENTAL FEATURE) With Razor based tests, you write tests in .razor files, which allows you to declare, in Razor syntax, the component under test and other markup fragments you need. You still write your assertions via C# in the .razor file, inside @code {...} blocks. Snapshot tests (EXPERIMENTAL FEATURE) Snapshot tests are written in .razor files. A test contains a definition of an input markup/component and the expected output markup. The library will then automatically perform an semantic HTML comparison. Very little C# is needed in this, usually only to configure services. In Snapshot testing , the rendering and verification is automatic. For C# based tests and Razor based tests , we have the following concepts to help us render our components and markup fragments: ITestContext for rendering using the RenderComponent method. The test context also allows you to configure services that should be available during rendering of components. IRazorTestContext extends ITestContext with methods for getting the declared components under test and any (markup) fragments in Razor based tests. And the following concepts to help us access the rendered markup and component: IRenderedFragment is returned when a fragment is rendered. It has query methods ( Find and FindAll ) for querying the rendered markup using CSS selectors. It also provides access to the raw markup via the Markup property and to a DOM tree representation of the rendered markup via the Nodes property. The library also provides extension methods attached to elements in the DOM tree, that allow you to trigger attached Razor event handlers, e.g. an @onclick event handler on a <button @onclick=\"...\"> . NOTE: The DOM tree implementation is provided by the AngleSharp library, which provides a full HTML5 compatible implementation of DOM APIs. That means you can use all the DOM APIs you know from the browser to inspect the rendered nodes. IRenderedComponent<TComponent> extends IRenderedFragment with methods for rendering a component again with new parameters if needed, and a property for accessing the instance of the component. The diagram below shows the four interfaces, their relationships to each other, and available methods. This is the basics of how components and markup is rendered and afterword's accessed for verification and further inspection."
  },
  "index.html": {
    "href": "index.html",
    "title": "bUnit - a testing library for Blazor Components | bUnit",
    "keywords": "bUnit - a testing library for Blazor Components bUnit , previously known as Blazor Components Testing Library , is a unit testing library for Blazor Components. You can easily define components under test in C# or Razor syntax, and verify outcome using semantic HTML diffing/comparison logic. You can interact with and inspect components, trigger event handlers, provide cascading values, inject services, mock IJsRuntime, and perform snapshot testing. This library's goal is to make it easy to write comprehensive, stable unit tests for Blazor Components/Razor Components. To see how, go to the Documentation pages . Contributors Shout outs and a big thank you to the contributors to this library. Here they are, in alphabetically: Michael J Conrad (@Siphonophora) Rastislav Novotn√Ω (@duracellko)"
  },
  "docs/contribute.html": {
    "href": "docs/contribute.html",
    "title": "Contribute | bUnit",
    "keywords": "Contribute To get in touch, ask questions or provide feedback, you can: Create a new issue . Join the library's Gitter channel Ping me on Twitter: @egilhansen There are a few ways you can help improve this library. Tell me if a certain type of component/scenario is hard to test. Create an issue with a minimal example of the component and the kind of assertions you would like to perform. Suggest tweaks to the library's API or assertion helpers (create issue). Find a bug or mistake in the library, create an issue, or even better, send in a pull request. Help with documentation and/or good examples. If you figured out a elegant way to test a scenario, share it through an issue, or add it to the samples project (pull request), or add it to the documentation (pull request)."
  },
  "docs/index.html": {
    "href": "docs/index.html",
    "title": "Introductions | bUnit",
    "keywords": "Introductions Before you start writing your first test, it is highly recommended that you go read the Getting started page, which will explain the difference between testing normal classes and Blazor/Razor components."
  },
  "docs/snapshot-testing.html": {
    "href": "docs/snapshot-testing.html",
    "title": "Snapshot testing | bUnit",
    "keywords": "Snapshot testing The library has basic support for snapshot testing, declared via Razor syntax in Razor files. In snapshot testing, you declare your input (e.g. one or more component under test) and the expected output, and the library will automatically tell you if they do not match. Notable features that are missing at the moment is the ability to auto-generate the expected output and to trigger updates of expected output. NOTE: This feature is EXPERIMENTAL and syntax and API will likely changed. Here are a few limitations to be aware of at the moment: The xUnit test runner can detect and execute tests in Razor test components, but is not able to distinguish the individual <SnapshotTest> 's from each other. They are all executed together, one at the time. The solution is planned, see the related issue for details. Go to the Contribute page for info on how to provide feedback and suggestions. Content: Creating new snapshot test component Defining snapshot test cases Executing test cases Examples Further reading: Semantic HTML markup comparison Creating new snapshot test component To create Razor-based snapshot tests, we need to create snapshot Razor test components. All snapshot test components must inherit from TestComponentBase , e.g. by adding @inherits TestComponentBase to the top of your .razor file. For example: @inherits TestComponentBase <SnapshotTest Description=\"Test 1\"> <TestInput>...</TestInput> <ExpectedOutput>...</ExpectedOutput> </SnapshotTest> <SnapshotTest Description=\"Test 2\"> <TestInput>...</TestInput> <ExpectedOutput>...</ExpectedOutput> </SnapshotTest> Defining snapshot test cases All you need to define a snapshot test case is the <SnapshotTest> component added to a test component, e.g.: <SnapshotTest Description=\"Helpful description of the test case - displayed if test fails\" Setup=\"() => Services.AddMockJsRuntime()\" SetupAsync=\"() => Task.CompletedTask\"> <TestInput><!-- Declare your test input here, e.g. one or more components --></TestInput> <ExpectedOutput><!-- Declare your expected output here --></ExpectedOutput> </SnapshotTest> You can add as many <SnapshotTest> components to a test component as you want. Each <SnapshotTest> component will go through this life cycle: Call the Setup and SetupAsync methods, if specified. Use the Setup / SetupAsync method to e.g. configure services, like registering a mock IJsRuntime . Render the child content of the <TestInput> component and capture its output. Render the child content of the <ExpectedOutput> component and capture its output. Verify that the two outputs are equal. If they are not, the test will fail with an HtmlEqualException . Executing test cases Since Snapshot tests use xUnit under the hood as a test runner, you execute your tests them in exactly the same way as you would normal xUnit unit tests, i.e. by running dotnet test from the console or running the tests through the Test Explorer in Visual Studio. Do note the current limitations mentioned at the top of the page. Examples The following example shows how to test the the TodoList.razor component: @inherits TestComponentBase <SnapshotTest Description=\"A todolist with one todo added should render correctly\" Setup=\"() => Services.AddMockJsRuntime()\" SetupAsync=\"() => Task.CompletedTask\"> <TestInput> <TodoList Label=\"My label\" Items=@(new Todo[]{ new Todo{ Id=42, Text=\"Check out this new thing called Blazor\" } })> <ItemsTemplate Context=\"todo\"> <TodoItem Todo=\"todo\"></TodoItem> </ItemsTemplate> </TodoList> </TestInput> <ExpectedOutput> <form> <div class=\"input-group\"> <input type=\"text\" class=\"form-control\" placeholder=\"My label\" aria-label=\"My label\" value=\"\" /> <div class=\"input-group-append\"> <button class=\"btn btn-secondary\" type=\"submit\">Add task</button> </div> </div> </form> <ol class=\"list-group\"> <li id:regex=\"todo-42\" class=\"list-group-item list-group-item-action\"> <span>Check out this new thing called Blazor</span> <span class=\"float-right text-danger\">(click to complete)</span> </li> </ol> </ExpectedOutput> </SnapshotTest>"
  },
  "docs/creating-a-new-test-project.html": {
    "href": "docs/creating-a-new-test-project.html",
    "title": "Creating a new test project | bUnit",
    "keywords": "Creating a new test project To create a project for testing you Blazor components, first install the bUnit Project Template from NuGet, using this command: dotnet new --install bunit.template::1.0.0-beta-6 Then to create a new project, use the following command: dotnet new bunit -o <NAME OF PROJECT> where -o <NAME OF PROJECT> is used to name the test project. Creating a new Blazor test project manually If you do not want to use the Blazor test project template, you can create an empty class library and the modify the .csproj to match the following: <Project Sdk=\"Microsoft.NET.Sdk.Razor\"> <PropertyGroup> <TargetFramework>netcoreapp3.1</TargetFramework> <RazorLangVersion>3.0</RazorLangVersion> </PropertyGroup> <ItemGroup> <PackageReference Include=\"Microsoft.AspNetCore.Components\" Version=\"3.1.0\" /> <PackageReference Include=\"Microsoft.AspNetCore.Components.Web\" Version=\"3.1.0\" /> <PackageReference Include=\"bunit\" Version=\"1.0.0-beta-6\" /> <PackageReference Include=\"Microsoft.NET.Test.Sdk\" Version=\"16.4.0\" /> <PackageReference Include=\"xunit\" Version=\"2.4.1\" /> <PackageReference Include=\"xunit.runner.visualstudio\" Version=\"2.4.1\"> <PrivateAssets>all</PrivateAssets> <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets> </PackageReference> </ItemGroup> </Project> Projects structure and tips and tricks The recommended solution/project structure for a test and production code project set-up is: src | MyComponentLib.csproj (namespace e.g. \"Company.MyComponentLib\") | _Imports.razor | Component1.razor | SubFolder | SubComponent1.razor test | MyComponentLibTests.csproj (with project reference to MyComponentLib.csproj) | _Imports.razor | Component1Test.cs | SubFolder | SubComponent1Test.cs Use same root namespace and folder structure in both test- and production project A neat trick, which will limit the import statements needed in your test project, is to set the root namespace to the same as that of the production code project, AND use the same folder structure as shown above. Following the example above, the MyComponentLibTests.csproj file should contain: <PropertyGroup> <RootNamespace>Company.MyComponentLib</RootNamespace> </PropertyGroup> Make copy/past of HTML easier When writing C# based tests, you sometime want to copy/paste some HTML into C# strings from e.g. a Razor file. This is tedious to do manually as you have to escape the quotes and other special characters. The extension, SmartPaster2019 , allows us to copy strings where any character that needs to be escaped will be automatically."
  },
  "docs/csharp-based-testing.html": {
    "href": "docs/csharp-based-testing.html",
    "title": "C# based testing | bUnit",
    "keywords": "C# based testing This pages documents how to do Blazor/Razor component testing using just C#. Before you get started, make sure you have read the Getting started page and in particular the Basics of Blazor component testing section. It wont take long, and it will ensure you get a good start at component testing. NOTE: You are currently required to write your tests using the xUnit framework. If popular demand requires it, this library can be made test framework independent in the future. TIP: Working with and asserting against the rendered component and its output is covered on the Working with rendered components and fragments page. Content: Creating an new test class Executing test cases Rendering components during tests Passing parameters and services to components during render Registering and injecting services into components during render Further reading: Working with rendered components and fragments Semantic HTML markup comparison Mocking JsRuntime C# test examples Creating an new test class All test classes are expected to inherit from ComponentTestFixture , which implements the ITestContext interface. The example below includes the needed using statements as well: using System; using Bunit; using Bunit.Mocking.JSInterop; using Microsoft.Extensions.DependencyInjection; using Xunit; public class MyComponentTest : ComponentTestFixture { [Fact] public void MyFirstTest() { // ... } } The ComponentTestFixture contains all the logic for rendering components and correctly dispose of renderers, components, and HTML parsers after each test. Executing test cases Since Blazor component tests are just regular xUnit test/facts, you execute them in exactly the same way as you would normal tests, i.e. by running dotnet test from the console or running the tests through the Test Explorer in Visual Studio. Rendering components during tests To render a component, we use the RenderComponent<TComponent>(params ComponentParameter[] parameters) method. It will take the component ( TComponent ) through its usual life-cycle from OnInitialized to OnAfterRender . For example: public class ComponentTest : ComponentTestFixture // implements the ITestContext interface { [Fact] public void Test1() { // Renders a MyComponent component and assigns the result to // a cut variable. CUT is short for Component Under Test. IRenderedComponent<MyComponent> cut = RenderComponent<MyComponent>(); } } The RenderComponent<TComponent>(params ComponentParameter[] parameters) : IRenderedComponent<MyComponent> method has these parts: TComponent is the type of component you want to render. ComponentParameter[] parameters represents parameters that will be passed to the component during render. IRenderedComponent<TComponent> is the representation of the rendered component. Working with the rendered component and its output is covered on the Working with rendered components and fragments page. Passing parameters to components during render There are four types of parameters you can pass to a component being rendered through the RenderComponent() method: Cascading values (normally provided by the <CascadingValue> component in .razor files). Event callbacks (of type EventCallback<T> or EventCallback ). Child content, render fragments, or templates (of type RenderFragment and RenderFragment<T> ). All other normal parameters, including unmatched parameters. In addition to parameters, services can also be registered in the ITestContext and injected during component render. To show how, let us look at a few examples that correctly pass parameters and services to the following AllTypesOfParams<TItem> component: @typeparam TItem @inject IJSRuntime jsRuntime @code { [Parameter(CaptureUnmatchedValues = true)] public IReadOnlyDictionary<string, object> Attributes { get; set; } [Parameter] public string RegularParam { get; set; } [CascadingParameter] public int UnnamedCascadingValue { get; set; } [CascadingParameter(Name = \"Named\")] public int NamedCascadingValue { get; set; } [Parameter] public EventCallback NonGenericCallback { get; set; } [Parameter] public EventCallback<EventArgs> GenericCallback { get; set; } [Parameter] public RenderFragment ChildContent { get; set; } [Parameter] public RenderFragment OtherContent { get; set; } [Parameter] public RenderFragment<TItem> ItemTemplate { get; set; } } And to render the AllTypesOfParams<TItem> component with all possible parameters set, use the following code: var cut = RenderComponent<AllTypesOfParams<string>>( // pass name-value attribute to be captured by the Attributes parameter (\"some-unmatched-attribute\", \"unmatched value\"), // pass value to the RegularParam parameter (\"RegularParam\", \"some value\"), // pass value to the UnnamedCascadingValue cascading parameter CascadingValue(42), // pass value to the NamedCascadingValue cascading parameter CascadingValue(\"Named\", 1337), // pass action callback to the NonGenericCallback parameter EventCallback(\"NonGenericCallback\", () => { /* logic here */ }), // pass action callback to the GenericCallback parameter EventCallback(\"GenericCallback\", (EventArgs args) => { /* logic here */ }), // pass render fragment to the ChildContent parameter ChildContent(\"<h1>hello world</h1>\"), // paas render fragment to the OtherContent parameter RenderFragment(\"OtherContent\", \"<h1>hello world</h1>\"), // pass an template render fragment to the ItemTemplate parameter Template<string>(\"ItemTemplate\", (item) => (builder) => { }) ); Regular parameters can easily be passed as (string name, object? value) pairs (they are automatically converted to a ComponentParameter). We see two examples of that with the \"RegularParam\" and the unmatched attribute \"some-unmatched-attribute\" . Cascading values can be passed both as named and unnamed via the CascadingValue helper method, as we see in the example above with \"UnnamedCascadingValue\" and \"NamedCascadingValue\" . Event callbacks can be passed as Func and Action types with and without input and return types, using the EventCallback helper method. The example above shows two examples in \"NonGenericCallback\" and \"GenericCallback\" Child content and general Render fragments is passed to a component using the ChildContent or RenderFragment helper methods. The ChildContent and RenderFragment methods has two overloads, one that takes a (markup) string and a generic version, e.g. for child content, ChildContent<TComponent>(params ComponentParameter[] parameters) , which will generate the necessary render fragment to render a component as the child content. Note that the methods takes the same input arguments as the RenderComponent method, which means it too can be passed all the types of parameters shown in the example above. Templates render fragments can be passed via the Template<TValue> method, which takes the name of the parameter and a RenderFragment<TValue> as input. Unfortunately, you will have to turn to the RenderTreeBuilder API to create templates at the moment. TIP: Use the nameof(Component.Parameter) method to get parameter names in a refactor-safe way. For example, if we have a component MyComponent with a parameter named RegularParam , then use this when rendering: var cut = RenderComponent<MyComponent>( (nameof(MyComponent.RegularParam), \"some value\") ); Registering and injecting services into components during render When testing components that require services to be injected into them, i.e. @inject IJsRuntime jsRuntime , you must register the services or a mock thereof before you render your component. This is done via the ITestContext.Services property. Once a component has been rendered, no more services can be added to the service collection. If for example we want to render the with a dependency on an IMyService , we first have to call one of the AddSingleton methods on the service collection and register it. All the normal AddSingleton ServiceCollection overloads are available. In the case if a IJsRuntime dependency, we can however use the built-in Mocking JsRuntime . For example: public class ComponentTest : ComponentTestFixture // implements the ITestContext interface { [Fact] public void Test1() { // Add an custom service to the services collection Services.AddSingleton<IMyService>(new MyService()); // Add the Mock JsRuntime service Services.AddMockJsRuntime(); // Renders a MyComponent component and assigns the result to // a cut variable. CUT is short for Component Under Test. IRenderedComponent<MyComponent> cut = RenderComponent<MyComponent>(); } } See the page Mocking JsRuntime for more details mock."
  },
  "docs/tutorials-and-presentations.html": {
    "href": "docs/tutorials-and-presentations.html",
    "title": "Presentations, guides, and tutorials | bUnit",
    "keywords": "Presentations, guides, and tutorials Presentations Testing Blazor Components - session from .NET Conf - Focus on Blazor Twitch/Live coding Blazor StateHasChanged: Blazor Component Unit Testing with Egil Hansen"
  },
  "docs/working-with-rendered-components-and-fragments.html": {
    "href": "docs/working-with-rendered-components-and-fragments.html",
    "title": "Working with the rendered components and fragments | bUnit",
    "keywords": "Working with the rendered components and fragments This page is on the todo list. To see examples of how to work with rendered components and fragments, go to the following pages: C# test examples Razor test examples"
  },
  "docs/getting-started.html": {
    "href": "docs/getting-started.html",
    "title": "Getting started | bUnit",
    "keywords": "Getting started Testing Blazor components is not the same as testing a regular class. It basically boils down to that Blazor components are not instantiated directly by you, using the new keyword, they are instead rendered, and their output is not directly available. Thus, for first time Blazor component testers, the recommended reading is (5-10 minutes): Basics of Blazor component testing Creating a new test project If you prefer a video based tutorial , check out: Testing Blazor Components - session from .NET Conf - Focus on Blazor After you know the basics, pick one of the following testing styles to start with: C# based testing Razor based testing Snapshot testing If you are unsure, go with C# based testing , as it is more stable and resembles the structure of normal unit tests. If you want a more Razor-native feel when declaring your tests, the Razor based testing or Snapshot testing approach is worth a look. But be warned, the API is likely to change."
  },
  "docs/razor-based-testing.html": {
    "href": "docs/razor-based-testing.html",
    "title": "Razor-based testing | bUnit",
    "keywords": "Razor-based testing This pages documents how to do Blazor/Razor component testing from .razor files. Before you get started, make sure you have read the Getting started page and in particular the Basics of Blazor component testing section. It wont take long, and it will ensure you get a good start at component testing. NOTE: This feature is EXPERIMENTAL and syntax and API will likely changed. Here are a few limitations to be aware of at the moment: The xUnit test runner can detect and execute tests in Razor test components, but is not able to distinguish the individual <Fixture> 's from each other. They are all executed together, one at the time. The solution is planned, see the related issue for details. Go to the Contribute page for info on how to provide feedback and suggestions. TIP: Working with and asserting against the rendered component and its output is covered on the Working with rendered components and fragments page. Content: Creating a new Razor test component Defining tests/fixtures in test components Executing test cases Further reading: Working with rendered components and fragments Semantic HTML markup comparison Mocking JsRuntime Razor test examples Creating a new Razor test component To create Razor based tests, we need to create test components. All test components must inherit from TestComponentBase , e.g. by adding @inherits TestComponentBase to the top of your .razor file. The TestComponentBase contains all the logic for rendering components and correctly dispose of renderers, components, and HTML parsers after each test. For example: @inherits TestComponentBase <Fixture Test=\"Test1\"> <ComponentUnderTest> <MyComponent /> </ComponentUnderTest> </Fixture> @code { void Test1() { // assert and verification } } You will also need to import a few namespaces to make asserting and mocking possible. They are best placed in an _Imports.razor file next to your Razor test components, e.g.: @using Microsoft.AspNetCore.Components.Web @using Microsoft.Extensions.DependencyInjection @using Bunit @using Bunit.Mocking.JSInterop @using Xunit NOTE: The _Imports.razor has already been created for you if you are using the Blazor test project template . Defining tests/fixtures in test components When you have a Razor test component created, its time to add test cases/fixtures to it. This is done via the <Fixture> component and related test methods and child components. Lets look at what options we have by setting up an empty test case, first the code: <Fixture Description=\"MyComponent renders as expected\" @* Optional - description is shown in error message if test fails *@ Setup=\"Setup\" @* Optional - method called first *@ SetupAsync=\"SetupAsync\" @* Optional - method called after Setup *@ Test=\"Test1\" @* Optional - method called after Setup/SetupAsync *@ TestAsync=\"Test1Async\" @* Optional - method called after Test *@ Tests=\"new Action[]{ Test2, Test3 }\"> @* Optional - methods are called after Test/TestAsync, one at the time *@ TestsAsync=\"new Func<Task>[]{ Test2Async, Test3Async }\"> @* Optional - methods are called after Tests, one at the time *@ <ComponentUnderTest> <MyComponent /> </ComponentUnderTest> <Fragment id=\"first\"> <h1>First Fragment</h1> </Fragment> <Fragment id=\"second\"> <MyOtherComponent /> </Fragment> </Fixture> @code { // Called first if present when added to the Setup parameter // on a <Fixture> component (can be named anything) void Setup() { // Add services and do other setup work in this method. Services.AddMockJsRuntime(); } // Called after Setup if present when added to the Setup parameter // on a <Fixture> component (can be named anything) Task SetupAsync() => Task.CompletedTask; // Called after Setup when added to the Test parameter to a // <Fixture> component (can be named anything) void Test1() { // Renders a MyComponent component and assigns the result to // a cut variable. CUT is short for Component Under Test. IRenderedComponent<MyComponent> cut = GetComponentUnderTest<MyComponent>(); // Renders the markup in the \"first\" fragment by calling GetFragment without an id. IRenderedFragment firstFragment = GetFragment(); // Renders the markup in the \"first\" fragment by calling GetFragment with an id. IRenderedFragment alsoFirstFragment = GetFragment(\"first\"); // Both first fragments refers to the same instance. Assert.Equal(firstFragment, alsoFirstFragment); // Renders a MyOtherComponent component defined in the second fragment. IRenderedComponent<MyOtherComponent> myOtherComponent = GetFragment<MyOtherComponent>(\"second\"); } Task Test1Async() => Task.CompletedTask; // Called after Test when added to the Tests parameter to a // <Fixture> component (can be named anything). Methods in // the Tests parameter is called in the order they are present in the // array. void Test2() { // do more testing on CUT, f1 and f2 by retriving them. } void Test3() { // do more testing on CUT, f1 and f2 by retriving them. } Task Test2Async() => Task.CompletedTask; Task Test3Async() => Task.CompletedTask; } The code above works as follows: All the <Fixture> components defined in the test component is found by the TestComponentBase 's test method. For each Fixture , it calls the related methods in the following order (if they are present): Setup SetupAsync Test TestAsync Tests , one at the time, in the order they appear in the array. TestsAsync , one at the time, in the order they appear in the array. The Description parameter on the <Fixture> element is displayed in the test runners error window if the test fails. It is inside child component <ComponentUnderTest> where you declare the component under test. Any markup or component fragments that is needed for the test can be declared inside the optional <Fragment> components. The Id parameter is optional, and only needed if you have more than one. To render and get the component under test or any of the fragments, use the GetComponentUnderTest<TComponent>() method, where TComponent is the type of the component you have defined under the <ComponentUnderTest> element. GetFragment() can be called both with and without a TComponent , e.g. if its just markup defined in it. If an id is not provided to the GetFragment method, the first declared <Fragment> is returned. Inside the test methods you can do all the things you can in C#-based tests, e.g. assert against the CUT. Executing test cases Since Blazor test component use xUnit under the hood as a test runner, you execute your tests them in exactly the same way as you would normal xUnit unit tests, i.e. by running dotnet test from the console or running the tests through the Test Explorer in Visual Studio. Do note the current limitations mentioned at the top of the page."
  },
  "api/index.html": {
    "href": "api/index.html",
    "title": "PLACEHOLDER | bUnit",
    "keywords": "PLACEHOLDER TODO: Add .NET projects to the src folder and run docfx to generate REAL API Documentation !"
  },
  "docs/csharp-test-examples.html": {
    "href": "docs/csharp-test-examples.html",
    "title": "C# test examples | bUnit",
    "keywords": "C# test examples In the following examples, the terminology component under test (abbreviated CUT) is used to mean the component that is the target of the test. The examples below use the Shouldly assertion library as well. If you prefer not to use that just replace the assertions with the ones from your own favorite assertion library. All examples can be found in the Tests folder in the Sample project . Content: Testing components without parameters Testing components with parameters 2.1. Passing new parameters to an already rendered component Testing components with child content Testing components with EventCallback parameters Testing components with cascading-value parameters Testing components that use on IJsRuntime 7.1 Verifying element references passed to InvokeAsync Testing components with injected dependencies Dispatching @on-events from tests Testing components without parameters The following unit-tests verifies that the Counter.razor component behaves correctly. Here is the source for the Counter component: @page \"/counter\" <h1>Counter</h1> <p> Current count: @currentCount </p> <button class=\"btn btn-primary\" @onclick=\"IncrementCount\">Click me</button> @code { int currentCount = 0; void IncrementCount() { currentCount++; } } The CounterTest.cs looks like this: public class CounterTest : ComponentTestFixture { [Fact] public void InitialHtmlIsCorrect() { // Arrange - renders the Counter component var cut = RenderComponent<Counter>(); // Assert // Here we specify expected HTML from CUT. var expectedHtml = @\"<h1>Counter</h1> <p>Current count: 0</p> <button class=\"\"btn-primary btn\"\">Click me</button>\"; // Here we use the HTML diffing library to assert that the rendered HTML // from CUT is semantically the same as the expected HTML string above. cut.MarkupMatches(expectedHtml); } [Fact] public void ClickingButtonIncreasesCountStrict() { // Arrange - renders the Counter component var cut = RenderComponent<Counter>(); // Act // Use a Find to query the rendered DOM tree and find the button element // and trigger the @onclick event handler by calling Click cut.Find(\"button\").Click(); // Assert // GetChangesSinceFirstRender returns list of differences since the first render, // in which we assert that there should only be one change, a text change where // the new value is provided to the ShouldHaveSingleTextChange assert method. cut.GetChangesSinceFirstRender().ShouldHaveSingleTextChange(\"Current count: 1\"); // Repeat the above steps to ensure that counter works for multiple clicks cut.Find(\"button\").Click(); cut.GetChangesSinceFirstRender().ShouldHaveSingleTextChange(\"Current count: 2\"); } [Fact] public void ClickingButtonIncreasesCountTargeted() { // Arrange - renders the Counter component var cut = RenderComponent<Counter>(); // Act // Use a Find to query the rendered DOM tree and find the button element // and trigger the @onclick event handler by calling Click cut.Find(\"button\").Click(); // Assert // Use a Find to query the rendered DOM tree and find the paragraph element // and assert that its text content is the expected (calling Trim first to remove insignificant whitespace) cut.Find(\"p\").TextContent.Trim().ShouldBe(\"Current count: 1\"); // Repeat the above steps to ensure that counter works for multiple clicks cut.Find(\"button\").Click(); cut.Find(\"p\").TextContent.Trim().ShouldBe(\"Current count: 2\"); } } A few things worth noting about the tests above: InitialHtmlIsCorrect uses the ShouldBe method that performs a semantic comparison of the generated HTML from CUT and the expected HTML string. That ensures that insignificant whitespace doesn't give false positives, among other things. The \" strict \" test ( ClickingButtonIncreasesCountStrict ) and the \" targeted \" test ( ClickingButtonIncreasesCountTargeted ) takes two different approaches to verifying CUT renders the expected output: The strict version generates a diff between the initial rendered HTML and the rendered HTML after the button click, and then asserts that the compare result only contains the expected change. The targeted version finds the <p> element expect to have changed, and asserts against its text content. With the targeted version, we cannot guarantee that there are not other changes in other places of the rendered HTML, if that is a concern, use the strict style. If it is not, then the targeted style can lead to simpler test. Testing components with parameters In the following tests we will pass regular parameters to a component under test, e.g. [Parameter] public SomeType PropName { get; set; } style properties, where SomeType is not a RenderFragment or a EventCallback type. The component under test will be the Aside.razor component, which looks like this: <aside @attributes=\"Attributes\"> @if (Header is { }) { <header>@Header</header> } @ChildContent </aside> @code { [Parameter(CaptureUnmatchedValues = true)] public IReadOnlyDictionary<string, object>? Attributes { get; set; } [Parameter] public string? Header { get; set; } [Parameter] public RenderFragment? ChildContent { get; set; } } The AsideTest.cs looks like this: public class AsideTest : ComponentTestFixture { [Fact(DisplayName = \"Aside should render header and additional parameters correctly\")] public void Test001() { // Arrange var header = \"Hello testers\"; var cssClass = \"some-class\"; // Act - render the Aside component with two parameters (passed as pairs of name, value tuples). // Note the use of the nameof operator to get the name of the Header parameter. This // helps keeps the test passing if the name of the parameter is refactored. // // This is equivalent to the follow Razor code: // // <Aside Header=\"Hello testers\" class=\"some-class\"> // </Aside> var cut = RenderComponent<Aside>( (nameof(Aside.Header), header), (\"class\", cssClass) ); // Assert - verify that the rendered HTML from the Aside component matches the expected output. cut.MarkupMatches($@\"<aside class=\"\"{cssClass}\"\"><header>{header}</header></aside>\"); } } In the test above, we use an overload of the RenderComponent<TComponent>() method, that allow us to pass regular parameters as pairs of (string name, object? value) . As highlighted in the code, I recommend using the nameof to get the name of declared parameters from the component, so any changes to the name through refactoring automatically updates the test. The second parameter, class is explicitly declared in the Aside class. It is instead Attributes parameter, that captures all unmatched parameters. Passing new parameters to an already rendered component Sometimes we want to test what happens when a component is re-rendered, possible with new parameters. This can be done using the cut.Render() and the cut.SetParametersAndRender() methods, for example: [Fact(DisplayName = \"Passing new parameters to Aside updates the rendered HTML correctly\")] public void Test002() { // Arrange - initial render of Aside var cut = RenderComponent<Aside>(); // Act - set the Header parameter and re-render the CUT cut.SetParametersAndRender((nameof(Aside.Header), \"HEADER\")); // Assert - Check that we have exactly one change since the first render, // and that it is an addition to the DOM tree cut.GetChangesSinceFirstRender() .ShouldHaveSingleChange() .ShouldBeAddition(\"<header>HEADER</header>\"); // Arrange - Create a snapshot of the current rendered HTML for later comparisons cut.SaveSnapshot(); // Act - Set the Header parameter to null again and re-render cut.SetParametersAndRender((nameof(Aside.Header), null)); // Assert - Check that we have exactly one change since compared with the snapshot we took, // and that it is an addition to the DOM tree. cut.GetChangesSinceSnapshot() .ShouldHaveSingleChange() .ShouldBeRemoval(\"<header>HEADER</header>\"); } Some notes on Test002 above: The cut.SetParametersAndRender() method has the same overloads as the RenderComponent() method. The ShouldHaveSingleChange() method asserts that only a single difference is found by the compare method, and returns that diff object. The ShouldBeAddition() method verifies that a difference is an addition with the specified content (doing a semantic HTML comparison). The cut.TakeSnapshot() method saves the current rendered HTML for later comparisons. The cut.GetChangesSinceSnapshot() compares the current rendered HTML with the one saved by the TakeSnapshot() method. Testing components with child content The Aside.razor component listed in the previous section also has a ChildContent parameter, so lets add a few tests that passes markup and components to it through that. public class AsideTest : ComponentTestFixture { [Fact(DisplayName = \"Aside should render child markup content correctly\")] public void Test003() { // Arrange var content = \"<p>I like simple tests and I cannot lie</p>\"; // Act // Act - render the Aside component with a child content parameter, // which is constructed through the ChildContent helper method. // // This is equivalent to the follow Razor code: // // <Aside> // <p>I like simple tests and I cannot lie</p> // </Aside> var cut = RenderComponent<Aside>( ChildContent(content) ); // Assert - verify that the rendered HTML from the Aside component matches the expected output. cut.MarkupMatches($@\"<aside>{content}</aside>\"); } [Fact(DisplayName = \"Aside should render a child component correctly\")] public void Test004() { // Arrange - set up test data var outerAsideHeader = \"Hello outside\"; var nestedAsideHeader = \"Hello inside\"; // Act - render the Aside component, passing a header to it // and a component to its child content. The ChildContent helper // method will pass the parameters it is given to the nested Aside // component. // // This is equivalent to the follow Razor code: // // <Aside Header=\"Hello outside\"> // <Aside Header=\"Hello inside\"></Aside> // </Aside> var cut = RenderComponent<Aside>( (nameof(Aside.Header), outerAsideHeader), ChildContent<Aside>( (nameof(Aside.Header), nestedAsideHeader) ) ); // Assert - verify that the rendered HTML from the Aside component matches the expected output. cut.MarkupMatches($@\"<aside> <header>{outerAsideHeader}</header> <aside> <header>{nestedAsideHeader}</header> </aside> </aside>\"); } } In Test003 above we use the ChildContent(...) helper method to create a ChildContent parameter and pass that to the Aside component. The overload, ChildContent<TComponent>(...) , used in Test004 , allows us to create a render fragment that will render a component (of type TComponent ) with the specified parameters. The ChildContent<TComponent>(...) has the same parameter options as the RenderComponent<TComponent> method has. Testing components with EventCallback parameters To show how to pass an EventCallback to a component under test, we will use the ThemedButton.razor , which looks like this: <button @onclick=\"HandleOnClick\" class=@Theme?.Value title=@Title?.Value @attributes=\"Attributes\"> @ChildContent </button> @code { [Parameter(CaptureUnmatchedValues = true)] public IReadOnlyDictionary<string, object>? Attributes { get; set; } [CascadingParameter] public ThemeInfo? Theme { get; set; } [CascadingParameter(Name = nameof(Title))] public ThemeInfo? Title { get; set; } [Parameter] public RenderFragment? ChildContent { get; set; } [Parameter] public EventCallback<MouseEventArgs> OnClick { get; set; } private Task HandleOnClick(MouseEventArgs args) => OnClick.InvokeAsync(args); } The relevant part of ThemedButtonTest.cs looks like this: public class ThemedButtonTest : ComponentTestFixture { [Fact(DisplayName = \"When button is clicked, the OnClick event callback is triggered\")] public void Test001() { var wasCalled = false; // Arrange - pass a lambda in as parameter to the OnClick parameter. // // This is equivalent to the follow Razor code: // // <ThemedButton OnClick=\"(_) => wasCalled = true\"></ThemedButton> var cut = RenderComponent<ThemedButton>( EventCallback(nameof(ThemedButton.OnClick), (MouseEventArgs _) => wasCalled = true) ); // Act - click the button in CUT cut.Find(\"button\").Click(); // Assert - check if callback was triggered wasCalled.ShouldBeTrue(); } } Test001 above uses the EventCallback(parammeterName, callback) helper method the generate a proper EventCallback object. There are many overloads, that should enable all the normal scenarios that is possible via Razor code. Testing components with cascading-value parameters If a component under test accepts cascading values, like ThemedButton.razor listed above, we can pass one or more cascading values to it like so: public class ThemedButtonTest : ComponentTestFixture { [Fact(DisplayName = \"Themed button uses provided theme info to set class attribute\")] public void Test002() { // Arrange - create an instance of the ThemeInfo class to passs to the ThemedButton var theme = new ThemeInfo() { Value = \"BUTTON\" }; // Act - Render the ThemedButton component, passing in the instance of ThemeInfo // as an _unnamed_ cascading value. // // This is equivalent to the follow Razor code: // // <CascadingValue Value=\"theme\"> // <ThemedButton></ThemedButton> // </CascadingValue> var cut = RenderComponent<ThemedButton>( CascadingValue(theme) ); // Assert - check that the class specified in the cascading value was indeed used. cut.Find(\"button\").ClassList.ShouldContain(theme.Value); } [Fact(DisplayName = \"Named cascading values are passed to components\")] public void Test003() { // Arrange - create two instances of the ThemeInfo class to passs to the ThemedButton var theme = new ThemeInfo() { Value = \"BUTTON\" }; var titleTheme = new ThemeInfo() { Value = \"BAR\" }; // Act - Render the ThemedButton component, passing in the instances of ThemeInfo // as an _unnamed_ and a _named_ cascading value. // // This is equivalent to the follow Razor code: // // <CascadingValue Value=\"theme\"> // <CascadingValue Name=\"Title\" Value=\"titleTheme\"> // <ThemedButton></ThemedButton> // </CascadingValue> // </CascadingValue> var cut = RenderComponent<ThemedButton>( CascadingValue(theme), CascadingValue(nameof(ThemedButton.Title), titleTheme) ); // Assert - check that the class and title specified in the cascading values was indeed used. var elm = cut.Find(\"button\"); elm.ClassList.ShouldContain(theme.Value); elm.GetAttribute(\"title\").ShouldContain(titleTheme.Value); } } Test002 above uses the CascadingValue(object value) helper method to pass an unnamed cascading value to the CUT. Test003 above demonstrates how multiple (named) cascading values can be passed to a component under test. Testing components that use on IJsRuntime It is not uncommon to have components use Blazor's JSInterop functionality to call JavaScript, e.g. after first render. To make it easy to mock calls to JavaScript, the library comes with a IJsRuntime mocking helper, that allows you to specify return how JSInterop calls should be handled, and to verify that they have happened. If you have more complex mocking needs, you could look to frameworks like Moq . To help us test the Mock JSRuntime, we have the WikiSearch.razor component, which looks like this: @inject IJSRuntime jsRuntime <p>@searchResult</p> @code { string searchResult = string.Empty; // Assumes the following function is available in the DOM // <script> // function queryWiki(query) { // return fetch('https://en.wikipedia.org/w/api.php?origin=*&action=opensearch&search=' + query) // .then(x => x.text()); // } // </script> protected override async Task OnAfterRenderAsync(bool firstRender) { if (firstRender) { searchResult = await jsRuntime.InvokeAsync<string>(\"queryWiki\", \"blazor\"); StateHasChanged(); } } } The WikiSearchTest.cs looks like this: public class WikiSearchTest : ComponentTestFixture { [Fact(DisplayName = \"WikiSearch renders an empty P element initially\")] public void Test001() { // Arrange // Registered the MockJsRuntime in \"Loose\" mode with the service provider used when rendering components. // JsRuntimeMockMode.Loose is the default. It configures the mock to just return the default // value for whatever is requested in a InvokeAsync call if no call has explicitly been set up. var jsMock = Services.AddMockJsRuntime(); // Act - render the WikiSearch component var cut = RenderComponent<WikiSearch>(); // Assert // Check that the components initial HTML is as expected // and that the mock was called with the expected JS identifier and arguments. cut.MarkupMatches(\"<p></p>\"); jsMock.VerifyInvoke(\"queryWiki\").Arguments.Single().ShouldBe(\"blazor\"); } [Fact(DisplayName = \"On first render WikiSearch uses JSInterop to query wiki and display the result\")] public void Test002() { // Arrange // Registered the MockJsRuntime in \"strict\" mode with the service provider used when rendering components. // JsRuntimeMockMode.Strict mode configures the mock to throw an error if it receives an InvokeAsync call // it has not been set up to handle. var jsMock = Services.AddMockJsRuntime(JsRuntimeMockMode.Strict); // Set up the mock to handle the expected call var expectedSearchResult = \"SEARCH RESULT\"; var plannedInvocation = jsMock.Setup<string>(\"queryWiki\", \"blazor\"); // Render the WikiSearch and verify that there is no content in the paragraph element var cut = RenderComponent<WikiSearch>(); cut.Find(\"p\").InnerHtml.ShouldBeEmpty(); // Act // Use the WaitForNextRender to block until the component has finished re-rendered. // The plannedInvocation.SetResult will return the result to the component is waiting // for in its OnAfterRender from the await jsRuntime.InvokeAsync<string>(\"queryWiki\", \"blazor\") call. WaitForNextRender(() => plannedInvocation.SetResult(expectedSearchResult)); // Assert // Verify that the result was received and correct placed in the paragraph element. cut.Find(\"p\").InnerHtml.ShouldBe(expectedSearchResult); } } Test001 just injects the mock in \"Loose\" mode. It means it will only returns a default(TValue) for calls to InvokeAsync<TValue>(...) it receives. This allows us to test components that expects a IJsRuntime to be injected, but where the test we want to perform isn't dependent on it providing any specific return value. In \"Loose\" mode it is still possible to call VerifyInvoke(identifier) and assert against the expected invocation. Test002 injects and configures the mock in strict mode. That requires us to configure all the expected calls the mock should handle. If it receives a call it has not been configured for, an exception is thrown and the test fails. The WaitForNextRender(Action) helper method is used to block until a (async) render completes, that the action passed to it has triggered. In Test002 we trigger a render by setting the result on the planned invocation, which causes the await jsRuntime.InvokeAsync<string>(\"queryWiki\", \"blazor\") call in the CUT to complete, and the component to trigger a re-render by calling the StateHasChanged() method. Verifying element references passed to InvokeAsync If you want to verify that a element reference ( ElementReference ) passed to a IJsRuntime.InvokeAsync call is references the expected DOM element, you can do so with the ShouldBeElementReferenceTo() assert helper. For example, consider the FocussingInput.razor component, which looks like this: @inject IJSRuntime jsRuntime <input @ref=\"_inputRef\" @attributes=\"Attributes\" /> @code { private ElementReference _inputRef; [Parameter(CaptureUnmatchedValues = true)] public IReadOnlyDictionary<string, object>? Attributes { get; set; } protected override async Task OnAfterRenderAsync(bool firstRender) { if (firstRender) { await jsRuntime.InvokeVoidAsync(\"document.body.focus.call\", _inputRef); } } } The the FocussingInputTest.cs looks like this: public class FocussingInputTest : ComponentTestFixture { [Fact(DisplayName = \"After first render, the new input field has focus\")] public void Test001() { // Arrange - add the IJsRuntime mock var jsRtMock = Services.AddMockJsRuntime(); // Act - render the FocussingInput component, causing // the OnAfterRender(firstRender: true) to be called var cut = RenderComponent<FocussingInput>(); // Assert // that there is a single call to document.body.focus.call var invocation = jsRtMock.VerifyInvoke(\"document.body.focus.call\"); // Assert that the invocation received a single argument // and that it was a reference to the input element. var expectedReferencedElement = cut.Find(\"input\"); invocation.Arguments.Single().ShouldBeElementReferenceTo(expectedReferencedElement); } } The last line verifies that there was a single argument to the invocation, and via the ShouldBeElementReferenceTo checks, that the <input /> was indeed the referenced element. Testing components with injected dependencies The demonstrate service injection, lets refactor the FetchData.razor component that comes with the default Razor app template, to make it more testable: Extract an interface from WeatherForecastService , name it IWeatherForecastService , and have FetchData take a dependency on it. Extract the <table> inside the else branch in the FetchData.razor component into its own component. Lets name it ForecastDataTable . In the FetchData.razor , pass the variable forecasts to the ForecastDataTable component. Now we just need a MockForecastService.cs . It looks like this: internal class MockForecastService : IWeatherForecastService { public TaskCompletionSource<WeatherForecast[]> Task { get; } = new TaskCompletionSource<WeatherForecast[]>(); public Task<WeatherForecast[]> GetForecastAsync(DateTime startDate) => Task.Task; } With the mock in place, we can write the FetchDataTest.cs , which looks like this: public class FetchDataTest : ComponentTestFixture { [Fact(DisplayName = \"Fetch data component renders expected initial markup\")] public void Test001() { // Arrange - add the mock forecast service Services.AddSingleton<IWeatherForecastService, MockForecastService>(); // Act - render the FetchData component var cut = RenderComponent<FetchData>(); // Assert that it renders the initial loading message var initialExpectedHtml = @\"<h1>Weather forecast</h1> <p>This component demonstrates fetching data from a service.</p> <p><em>Loading...</em></p>\"; cut.MarkupMatches(initialExpectedHtml); } [Fact(DisplayName = \"After data loads it is displayed in a ForecastTable component\")] public void Test002() { // Setup the mock forecast service var forecasts = new[] { new WeatherForecast { Date = DateTime.Now, Summary = \"Testy\", TemperatureC = 42 } }; var mockForecastService = new MockForecastService(); Services.AddSingleton<IWeatherForecastService>(mockForecastService); // Arrange - render the FetchData component var cut = RenderComponent<FetchData>(); // Act - pass the test forecasts to the component via the mock services WaitForNextRender(() => mockForecastService.Task.SetResult(forecasts)); // Assert // Render an new instance of the ForecastDataTable, passing in the test data var expectedDataTable = RenderComponent<ForecastDataTable>((nameof(ForecastDataTable.Forecasts), forecasts)); // Assert that the CUT has two changes, one removal of the loading message and one addition which matched the // rendered HTML from the expectedDataTable. cut.GetChangesSinceFirstRender().ShouldHaveChanges( diff => diff.ShouldBeRemoval(\"<p><em>Loading...</em></p>\"), diff => diff.ShouldBeAddition(expectedDataTable) ); } } In Test001 we use the Services.AddSingleton method to register the dependency and the performs a regular \"initial render\" verification. Test002 creates a new instance of the mock service and registers that with the the service provider. It then renders the CUT and uses WaitForNextRender to pass the test data to the mock services task, which then completes and the CUT gets the data. In the assert step we expect the CUT to use a ForecastDataTable to render the forecast data. Thus, to make our assertion more simple and stable to changes, we render an instance of the ForecastDataTable use that to verify that the expected addition after the CUT receives the forecast data is as it should be. Dispatching @on-events during testing In the previous sections we have seen a few examples of method calls that trigger @on-event handlers, e.g. cut.Find(selector).Click() that triggers the @onclick event handler attached to the element that matches the search query. The following triggers are currently available in PascalCase, without the @on -prefix. E.g. the @onbeforeactivate event is available as BeforeActivate() in various overloads."
  },
  "docs/razor-test-examples.html": {
    "href": "docs/razor-test-examples.html",
    "title": "Razor test examples | bUnit",
    "keywords": "Razor test examples In the following examples, the terminology component under test (abbreviated CUT) is used to mean the component that is the target of the test. The examples below use the Shouldly assertion library as well. If you prefer not to use that just replace the assertions with the ones from your own favorite assertion library. All examples can be found in the Tests folder in the Sample project . Examples Here is a few examples that demonstrate how Razor test components can be used. More can be found in the sample/tests/RazorComponentTests samples folder. <Fixture Test=\"ThemedButtonUsesNamedCascadingValue\"> <ComponentUnderTest> <CascadingValue Name=@nameof(ThemedElement.Class) Value=@(new ThemeInfo { Value = \"FOO\" })> <CascadingValue Name=@nameof(ThemedElement.Title) Value=@(new ThemeInfo { Value = \"BAR\" })> <ThemedElement /> </CascadingValue> </CascadingValue> </ComponentUnderTest> </Fixture> @code { void ThemedButtonUsesNamedCascadingValue() { var cut = GetComponentUnderTest(); var elm = cut.Find(\"div\"); elm.ClassList.ShouldContain(\"FOO\"); elm.GetAttribute(\"title\").ShouldContain(\"BAR\"); } } This example shows how ThemedElement.razor can be tested with cascading values. <Fixture Test=MarkupPassedViaChildContent> <ComponentUnderTest> <ThemedButton> <h1>Foo bar button</h1> </ThemedButton> </ComponentUnderTest> <Fragment><h1>Foo bar button</h1></Fragment> </Fixture> @code { void MarkupPassedViaChildContent() { var expectedChildContent = GetFragment(); var cut = GetComponentUnderTest(); cut.Find(\"button\").ChildNodes.MarkupMatches(expectedChildContent); } } This example shows how ThemedButton.razor can be tested with with child content, and how a <Fragment> can be used to specify the expected output. Lets look at a more complex example, a test of the TodoList.razor component: <Fixture Setup=\"() => Services.AddMockJsRuntime()\" Test=\"EmptyTodoList\" Tests=\"new Action[]{ SettingLabel, TaskListRendersItemsUsingItemTemplate }\"> <ComponentUnderTest> <TodoList> <ItemsTemplate> <TodoItem Todo=@context /> </ItemsTemplate> </TodoList> </ComponentUnderTest> <Fragment Id=\"EmptyTodoListRender\"> <form> <div class=\"input-group\"> <input value=\"\" type=\"text\" class=\"form-control\" placeholder=\"Task description\" aria-label=\"Task description\" /> <div class=\"input-group-append\"> <button class=\"btn btn-secondary\" type=\"submit\">Add task</button> </div> </div> </form> <ol class=\"list-group\"></ol> </Fragment> <Fragment Id=\"TodoItemRender\"> <TodoItem Todo=\"@TestItems[0]\" /> </Fragment> </Fixture> @code { Todo[] TestItems { get; } = new[] { new Todo { Id = 42 } }; void EmptyTodoList() { // Act - get the CUT var cut = GetComponentUnderTest<TodoList>(); // Assert - get the expected initial rendered HTML from the fragment // and use it to verify the initial rendered HTML var expectedInitialRender = GetFragment(\"EmptyTodoListRender\"); cut.MarkupMatches(expectedInitialRender); } void SettingLabel() { // Arrange - get the CUT var cut = GetComponentUnderTest<TodoList>(); // Act - update label cut.SetParametersAndRender((nameof(TodoList.Label), \"LABEL\")); // Assert - verifiy that the placeholder and aria-label has changed cut.GetChangesSinceFirstRender().ShouldAllBe( diff => diff.ShouldBeAttributeChange(\"placeholder\", \"LABEL\"), diff => diff.ShouldBeAttributeChange(\"aria-label\", \"LABEL\") ); } void TaskListRendersItemsUsingItemTemplate() { // Arrange - get the cut and take a snapshot of the current render tree output var cut = GetComponentUnderTest<TodoList>(); cut.SaveSnapshot(); // Act - assign test todo items to the CUT cut.SetParametersAndRender((nameof(TodoList.Items), TestItems)); // Assert - get the diffs since the snapshot and compare to the expected. var diffs = cut.GetChangesSinceSnapshot(); var expected = GetFragment(\"TodoItemRender\"); diffs.ShouldHaveSingleChange().ShouldBeAddition(expected); } } A few things worth noting here: The Fixture methods are called in this order: Setup (inline) EmptyTodoList SettingLabel TaskListRendersItemsUsingItemTemplate The CUT is only initialized once, the first time GetComponentUnderTest<TodoList>() is called. Subsequent calls return the same instance. The follow test verifies some of the component logic around new todo creation and setting focus to the input field on first render: <Fixture Setup=\"Setup\" Tests=\"new Action[]{ OnFirstRenderInputFieldGetsFocus, AfterFirstRenderInputFieldDoesntGetFocusAfterRerenders, WhenAddTaskFormIsSubmittedWithNoTextOnAddingTodoIsNotCalled }\"> <ComponentUnderTest> <TodoList OnAddingTodo=\"OnAddingTodoHandler\"> <ItemsTemplate> <TodoItem Todo=@context /> </ItemsTemplate> </TodoList> </ComponentUnderTest> </Fixture> @code { MockJsRuntimeInvokeHandler jsRtMock = default!; Todo? createdTodo; void OnAddingTodoHandler(Todo todo) => createdTodo = todo; void Setup() { jsRtMock = Services.AddMockJsRuntime(); } void OnFirstRenderInputFieldGetsFocus() { // Act var cut = GetComponentUnderTest<TodoList>(); // Assert that there is a call to document.body.focus.call with a single argument, // a reference to the input element. jsRtMock.VerifyInvoke(\"document.body.focus.call\") .Arguments.Single().ShouldBeElementReferenceTo(cut.Find(\"input\")); } void AfterFirstRenderInputFieldDoesntGetFocusAfterRerenders() { // Arrange var cut = GetComponentUnderTest<TodoList>(); // Act cut.Render(); // second render cut.Render(); // thrid render cut.Render(); // ... cut.Render(); // Assert that focus logic only runs on first render (only called 1 time). jsRtMock.VerifyInvoke(\"document.body.focus.call\", calledTimes: 1); } void WhenAddTaskFormIsSubmittedWithNoTextOnAddingTodoIsNotCalled() { // Arrange var cut = GetComponentUnderTest<TodoList>(); // Act - submit the empty form cut.Find(\"form\").Submit(); // Assert - verify that no task was created Assert.Null(createdTodo); } void WhenAddTaskFormIsSubmittedWithTextOnAddingTodoIsCalled() { // Arrange - ensure createdTask is null createdTodo = null; var cut = GetComponentUnderTest<TodoList>(); var taskValue = \"HELLO WORLD TASK\"; // Act - find input field and change its value, then submit the form cut.Find(\"input\").Change(taskValue); cut.Find(\"form\").Submit(); // Assert that a new task has been passed to the EventCallback listener and that the // new task has the expected value Assert.NotNull(createdTodo); Assert.Equal(taskValue, createdTodo?.Text); } } More examples to come."
  },
  "docs/semantic-html-markup-comparison.html": {
    "href": "docs/semantic-html-markup-comparison.html",
    "title": "Semantic HTML markup comparison | bUnit",
    "keywords": "Semantic HTML markup comparison This library includes comparison and assert helpers that uses the AngleSharp Diffing library to perform semantic HTML comparison. On this page we will go through how the comparison works, and what options you have to affect the comparison process. NOTE: The semantic HTML comparison is available in all three test types, but is always used in the Snapshot test type. Content: Why semantic comparison is needed for stable tests Customizing the comparison process Verifying output from components Different ways of getting the differences Why semantic comparison is needed for stable tests Just performing string comparison of two strings containing HTML markup can break quite easily, even if the two markup strings are semantically equivalent. Some changes that can cause a regular string comparison to fail are: Formatting of markup, e.g. with extra line breaks or indentions, changes to insignificant whitespace. Reordering of attributes. The order of attributes does not matter. Reordering of classes defined in the class=\"...\" attribute. The order of classes does not matter. Change of boolean attribute to be implicit or explicit, e.g. from required=\"required\" to required . Change to insignificant whitespace inside <style> tags. Changes to HTML comments and comments inside <style> tags. The AngleSharp Diffing library handles all those cases, so your tests are more stable. Customizing the comparison process The AngleSharp Diffing library also allows us to customize the comparison process, by added special attributes to the \"control\" markup , i.e. the expected markup we want to use in verification. There are the customization options you have available to you: Ignore comments (enabled by default): Comments in markup and inside <style> tags are automatically ignored and not part of the comparison process. Ignore element: Use the diff:ignore attribute to ignore an element, all it's attributes and child nodes. For example, to ignore the h1 element: <header> <h1 class=\"heading-1\" diff:ignore>Hello world</h1> </header> Ignore attribute: To ignore an attribute during comparison, add the :ignore modifier to the attribute (no value is needed). For example, to ignore the class attribute: <header> <h1 class:ignore=\"heading-1\">Hello world</h1> </header> Configure whitespace handling: By default all nodes and elements are compared using the Normalize whitespace handling option. The Normalize option will trim all text nodes and replace two or more whitespace characters with a single space character. The other options are Preserve , which will leave all whitespace unchanged, and RemoveWhitespaceNodes , which will only remove empty text nodes. To override the default option, use the diff:whitespace attribute, and pass one of the three options to it, for example: <header> <h1 diff:whitespace=\"preserve\">Hello <em> woooorld</em></h1> </header> NOTE: The default for <pre> and <script> elements is the Preserve option. To change that, use the diff:whitespace attribute, for example: <pre diff:whitespace=\"RemoveWhitespaceNodes\">...</pre> Perform case insensitive comparison: By default, all text comparison is case sensitive, but if you want to perform a case insensitive comparison of text inside elements or attributes, use the diff:ignoreCase attributes on elements and :ignoreCase modifier on attributes. For example, to do case insensitive comparison of the text in the h1 element: <h1 diff:ignoreCase>HellO WoRlD</h1> To do case insensitive comparison of the text inside the title attribute: <h1 title:ignoreCase=\"HeaDinG\">...</h1> Use RegEx during comparison: To use a regular expression when comparing the text inside an element or inside an attribute, use the diff:regex on elements and :regex modifier on attributes. For example, to use a regular expression during comparison of the text in the h1 element, add the diff:regex attribute to the element and place the regular expression in the body of the element: <h1 diff:regex diff:ignoreCase>Hello World \\d{4}</h1> To use a regular expression during comparison of the text inside the title attribute, add the :regex modifier to attribute and add the regular expression in the attributes value: <h1 title:regex=\"Heading-\\d{4}\">...</h1> NOTE: The attribute modifiers :ignoreCase and :regex can be combined, for example as: attr:ignoreCase:regex=\"FOO-\\d{4}\" Verifying output from components To verify the rendered output of a component (i.e. in the from of a IRenderedFragment ), we have the various MarkupMatches() methods we can use. If for example we have a component, <Heading> , that renders the following markup: <h3 id=\"heading-1337\" required> Heading text <small class=\"text-muted mark\">Secondary text</small> </h3> If we want to verify the markup is rendered correctly, and for example use RegEx to verify the id attribute (it might be generated) and ignore the <small> element, we can do it like this in C# based tests: [Fact] public void InitialHtmlIsCorrect() { // Arrange - renders the Heading component var cut = RenderComponent<Heading>(); // Assert // Here we specify expected HTML from CUT. var expectedHtml = @\"<h3 id:regex=\"\"heading-\\d{4}\"\" required> Heading text <small diff:ignore></small> </h3>\"; // Here we use the HTML diffing library to assert that the rendered HTML // from CUT is semantically the same as the expected HTML string above. cut.MarkupMatches(expectedHtml); } In a Razor based test, the example looks like this: <Fixture Test=\"Test1\"> <ComponentUnderTest> <Heading /> </ComponentUnderTest> </Fixture> @code { void Test1(IRazorTestContext context) { // Arrange - Gets the Heading component var cut = context.GetComponentUnderTest<Heading>(); // Assert // Here we specify expected HTML from CUT. var expectedHtml = @\"<h3 id:regex=\"\"heading-\\d{4}\"\" required> Heading text <small diff:ignore></small> </h3>\"; // Here we use the HTML diffing library to assert that the rendered HTML // from CUT is semantically the same as the expected HTML string above. cut.MarkupMatches(expectedHtml); } } In a Snapshot test, the example looks like this: <SnapshotTest Description=\"Helpful description of the test case\"> <TestInput> <Heading /> </TestInput> <ExpectedOutput> <h3 id:regex=\"heading-\\d{4}\" required> Heading text <small diff:ignore></small> </h3> </ExpectedOutput> </SnapshotTest> Different ways of getting the differences This section is coming soon. For now, see examples on the C# test examples page where the methods are demonstrated. Look for examples using these methods: CompareTo MarkupMatches GetChangesSinceFirstRender SaveSnapshot and GetChangesSinceSnapshot ShouldHaveSingleTextChange ShouldHaveSingleChange ShouldBeAddition ShouldBeRemoval"
  }
}